@doc raw"""
# Random Telegraph Noise (RTN)
RTN is a type of random signal with two states, on or off, up or down, _etc._ with a mean
_dwell time_ ``T_D`` which characterizes the amount of time the signal spends in each state 
before switching.

This module provides an easy framework to generate such signals, as they happen to have 
well known analytical properties. For example, the autocovariance of the signal (often 
called the _autocorrelation_ physics literature) goes as 
```math
\mathcal{A}(t, t_0; T_D) = \exp\left( -2\frac{\vert t - t_0 \vert}{T_D} \right). 
```
Therefore, the characteristic _autocorrelation time_ ``\tau = T_D/2``. Importantly, the 
expression above shows that these random signals are _stationary_ meaning that correlations
are time-translation invariant. This means a random telgraph signal is well-suited for testing
autocorrelations of random signals, for example those generated by Markov Chain Monte Carlo 
methods.
"""
module TelegraphNoise

export Telegraph, expd_τ, generate_telegraph, generate_telegraph!

"""
    expd_τ(tele::Telegraph{T}) → T

Return the expected autocorrelation time from a random telegraph signal.
"""
expd_τ(tele::Telegraph ) = convert(typeof(tele.dwell_time), 0.5) * tele.dwell_time

"""
    Telegraph(dwell_time, signal)

Wrapper that contains the relevant information for a given `Telegraph` signal. 
"""
struct Telegraph{T <: AbstractFloat}
    dwell_time::T
    signal::Vector{T}
end

"""
    Telegraph(dwell_time, signal_length::Int)

Constructor that specifies the length of the signal rather than the signal itself.
"""
Telegraph(dwell_time, signal_length::Int) = generate_telegraph(dwell_time, signal_length)

"""
    generate_telegraph( dwell_time, signal_length ) → Telegraph

Function that initializes a random [`Telegraph`](@ref) signal with a 
specified `dwell_time` and of a given length `signal_length`.
"""
function generate_telegraph( dwell_time, signal_length )

    signal::Vector{Float64} = []
    stepsize = floor(Int, -dwell_time * log( 1 - rand() ))
    while stepsize < 1
        stepsize = floor(Int, -dwell_time * log( 1 - rand() ))
    end
    append!(signal, ones(stepsize))
    while length(signal) < Int(signal_length)
        stepsize = floor(Int, -dwell_time * log( 1 - rand() ))
        if signal[end] == 1
            append!(signal, zeros(stepsize))
        else
            append!(signal, ones(stepsize))
        end
    end
    return Telegraph( dwell_time, signal[1:signal_length] )
end

"""
    
"""


end
