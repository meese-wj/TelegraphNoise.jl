@doc raw"""
# Random Telegraph Noise (RTN)
RTN is a type of random signal with two states, on or off, up or down, _etc._ with a mean
_dwell time_ ``T_D`` which characterizes the amount of time the signal spends in each state 
before switching.

This module provides an easy framework to generate such signals, as they happen to have 
well known analytical properties. For example, the autocovariance of the signal (often 
called the _autocorrelation_ in physics literature) goes as 
```math
\mathcal{A}(t, t_0; T_D) = \exp\left( -2\,\frac{\vert t - t_0 \vert}{T_D} \right). 
```
Therefore, the characteristic _autocorrelation time_ ``\tau = T_D/2``. Importantly, the 
expression above shows that these random signals are _stationary_ meaning that correlations
are time-translation invariant. This means a random telgraph signal is well-suited for testing
autocorrelations of random signals, for example those generated by Markov Chain Monte Carlo 
methods.
"""
module TelegraphNoise

using Random
import Base

export Telegraph, length, eltype, expd_τ, generate_telegraph, generate_telegraph!, poisson_rand

"""
    Telegraph{T}([amplitude = one(T)], dwell_time, signal)

Wrapper that contains the relevant information for a given `Telegraph` signal. 
"""
struct Telegraph{T <: AbstractFloat}
    amplitude::T
    dwell_time::T
    signal::Vector{T}
end
function Telegraph(amplitude::Real, dwell_time::Real, signal::Vector)
    _check_telegraph_params(amplitude, dwell_time)
    return Telegraph( convert(Float64, amplitude), convert(Float64, dwell_time), convert.(Float64, signal) )
end

function _check_telegraph_params(amplitude::Real, dwell_time::Real)
    if amplitude <= zero(amplitude)
        throw(ArgumentError("\nSignal amplitudes must be positive.\n"))
    end
    if dwell_time <= zero(dwell_time)
        throw(ArgumentError("\nSignal dwell times must be positive.\n"))
    end
    return nothing
end

function _check_telegraph_params(amplitude::Real, dwell_time::Real, signal_length)
    _check_telegraph_params(amplitude, dwell_time)
    if signal_length <= zero(Int)
        throw(ArgumentError("\nSignal length must be convertible to a positive integer.\n"))
    end
    return nothing
end


"""
    length(tele::Telegraph) → Int

Dispatch `Base.length` for the [`Telegraph`](@ref) object. 

# Additional information
* Wrapper around `length(tele.signal)`.
"""
Base.length(tele::Telegraph) = Base.length(tele.signal)

"""
    eltype(tele::Telegraph) → Type

Dispatch `Base.eltype` for the [`Telegraph`](@ref) object.

# Additional information
* Wrapper around `Base.eltype(tele.signal)`.
"""
Base.eltype(tele::Telegraph) = eltype(tele.signal)

"""
    expd_τ(tele::Telegraph{T}) → T

Return the expected autocorrelation time from a random telegraph signal.
"""
expd_τ(tele::Telegraph) = convert(typeof(tele.dwell_time), 0.5) * tele.dwell_time

Telegraph(dwell_time::T, signal::Vector{T}) where {T <: AbstractFloat} = Telegraph(one(T), dwell_time, signal)

"""
    Telegraph{T}([rng = default_rng()], [amplitude = one(T)], dwell_time, signal_length::Int)

Constructor that specifies the length of the signal rather than the signal itself.
"""
Telegraph(rng::AbstractRNG, amplitude::Real, dwell_time::Real, signal_length::Real) = generate_telegraph(rng, dwell_time, signal_length; amplitude = amplitude)
Telegraph(rng::AbstractRNG, dwell_time::Real, signal_length::Real) = generate_telegraph(rng, convert(Float64, dwell_time), signal_length)
Telegraph(amplitude, dwell_time, signal_length::Real) = generate_telegraph(convert(Float64, dwell_time), signal_length; amplitude = convert(Float64, amplitude))
Telegraph(dwell_time::Real, signal_length::Real) = generate_telegraph(convert(Float64, dwell_time), signal_length)

"""
    generate_telegraph([rng = default_rng()], dwell_time, signal_length; amplitude = one(T) ) → Telegraph

Function that initializes a random [`Telegraph`](@ref) signal with a 
specified `dwell_time` and of a given length `signal_length`.
"""
function generate_telegraph(rng::AbstractRNG, dwell_time::Real, signal_length; amplitude = one(Float64) )
    signal_length = convert(Int, signal_length)
    _check_telegraph_params(amplitude, dwell_time)

    tele = Telegraph(amplitude, dwell_time, zeros(Float64, signal_length))
    last_idx = 1
    tele.signal[last_idx] = ifelse( rand(rng) < 0.5, tele.amplitude, -tele.amplitude )
    while last_idx < signal_length
        stepsize = poisson_rand(dwell_time)
        stepsize = ifelse( last_idx + 1 + stepsize > signal_length, signal_length - (last_idx + 1), stepsize )
        next_value = ifelse( tele.signal[last_idx] == tele.amplitude, -tele.amplitude, tele.amplitude )
        tele.signal[last_idx + 1 : last_idx + 1 + stepsize] .= next_value
        last_idx = last_idx + 1 + stepsize
    end
    return tele
end
generate_telegraph(dwell_time::T, signal_length; amplitude = one(T)) where {T <: Real} = generate_telegraph(Random.default_rng(), dwell_time, signal_length; amplitude = amplitude)

@doc raw"""
    poisson_rand([rng = default_rng()], ::Type{T}, dwell_time, []) → T

Generate a random number of steps in which to stay in the next state.

# Additional information
The probability that an RTN signal will _dwell_ in its current state for a time
``t \in (t_0, t_0 + {\rm d} t)`` is given by 
```math
{\rm Pr}\left( t \in (t_0, t_0 + {\rm d} t) \right) = {\rm e}^{-t/T_D} \cdot \frac{{\rm d}t}{T_D}.
```

One then samples from this probability distribution using the _inverse-CDF_ method and obtains
```math
t \approx {\rm floor} \left[ -T_D \ln \left( 1 - u \right)  \right],
```
with ``u \in (0, 1)`` being a uniform random `Float` generated by `rand()`. The approximation 
is necessary as ``t`` represents a discrete time in a time series. 
"""
poisson_rand(::Type{T}, dwell_time) where {T} = _poisson_floor(T, dwell_time)
poisson_rand(rng::AbstractRNG, ::Type{T}, dwell_time) where {T} = _poisson_floor(T, dwell_time, rng)
_poisson_func(dwell_time, rng::AbstractRNG = Random.default_rng()) = -dwell_time * log(1.0 - rand(rng))
_poisson_floor(::Type{T}, dwell_time, rng::AbstractRNG = Random.default_rng()) where {T} = floor(T, _poisson_func(dwell_time, rng))

"""
    poisson_rand([rng = default_rng()], dwell_time) → Int

Default implementation of the [`poisson_rand`](@ref) is to return an `Int` for the size of the _dwell_.
"""
poisson_rand(dwell_time) = poisson_rand(Int, dwell_time)
poisson_rand(rng::AbstractRNG, dwell_time) = poisson_rand(rng, Int, dwell_time)


end
